import {DocumentVideoIcon, UploadIcon} from '@sanity/icons'
import {Box, Button, Card, Checkbox, Dialog, Flex, Label, Radio, Stack, Text} from '@sanity/ui'
import {uuid} from '@sanity/uuid'
import LanguagesList from 'iso-639-1'
import {useEffect, useId, useReducer, useRef} from 'react'
import {FormField} from 'sanity'

import formatBytes from '../util/formatBytes'
import {
  type AutogeneratedTextTrack,
  type ImageKitNewAssetSettings,
  isAutogeneratedTrack,
  type PluginConfig,
  type Secrets,
  type SupportedLanguage,
  type UploadConfig,
  type UploadTextTrack,
} from '../util/types'
import TextTracksEditor, {type TrackAction} from './TextTracksEditor'
import type {StagedUpload} from './Uploader'

export type UploadConfigurationStateAction =
  | {action: 'quality'; value: number}
  | {action: 'max_resolution'; value: UploadConfig['max_resolution']}
  | {action: 'transformation'; value: UploadConfig['transformation']}
  | {action: 'private'; value: UploadConfig['private']}
  | TrackAction

const TRANSFORMATION_OPTIONS = [
  {value: 'auto', label: 'Auto'},
  {value: 'custom', label: 'Custom'},
] as const

const RESOLUTION_OPTIONS = [
  {value: '480p', label: '480p'},
  {value: '720p', label: '720p'},
  {value: '1080p', label: '1080p'},
  {value: '1440p', label: '1440p (2k)'},
  {value: '2160p', label: '2160p (4k)'},
] as const

/**
 * The modal for configuring a staged upload. Handles triggering of the asset
 * upload, even if no modal needs to be shown.
 *
 * @returns
 */
export default function UploadConfiguration({
  stagedUpload,
  secrets,
  pluginConfig,
  startUpload,
  onClose,
}: {
  stagedUpload: StagedUpload
  secrets: Secrets
  pluginConfig: PluginConfig
  startUpload: (settings: ImageKitNewAssetSettings) => void
  onClose: () => void
}) {
  const id = useId()
  const autoTextTracks = useRef<NonNullable<UploadConfig['text_tracks']>>(
    pluginConfig.defaultAutogeneratedSubtitleLang
      ? [
          {
            _id: uuid(),
            type: 'autogenerated',
            language_code: pluginConfig.defaultAutogeneratedSubtitleLang,
            name: LanguagesList.getNativeName(pluginConfig.defaultAutogeneratedSubtitleLang),
          } satisfies AutogeneratedTextTrack,
        ]
      : []
  ).current

  const [config, dispatch] = useReducer(
    (prev: UploadConfig, action: UploadConfigurationStateAction) => {
      switch (action.action) {
        case 'transformation':
          // If transformation switches to custom, we keep existing values
          return Object.assign({}, prev, {transformation: action.value})

        case 'quality':
        case 'max_resolution':
          return Object.assign({}, prev, {[action.action]: action.value})
        case 'private':
          return Object.assign({}, prev, {[action.action]: action.value})
        // Updating individual tracks
        case 'track': {
          const text_tracks = [...prev.text_tracks]
          const target_track_i = text_tracks.findIndex(({_id}) => _id === action.id)
          // eslint-disable-next-line default-case
          switch (action.subAction) {
            case 'add':
              // Exit early if track already exists
              if (target_track_i !== -1) break
              text_tracks.push({
                _id: action.id,
                ...action.value,
              } as AutogeneratedTextTrack)
              break
            case 'update':
              if (target_track_i === -1) break
              text_tracks[target_track_i] = {
                ...text_tracks[target_track_i],
                ...action.value,
              } as UploadTextTrack
              break
            case 'delete':
              if (target_track_i === -1) break
              text_tracks.splice(target_track_i, 1)
              break
          }
          return Object.assign({}, prev, {text_tracks})
        }
        default:
          return prev
      }
    },
    {
      transformation: pluginConfig.transformation,
      max_resolution: pluginConfig.max_resolution,
      quality: pluginConfig.quality,
      private: secrets.enablePrivateImages || pluginConfig.defaultPrivate || false,
      is_protected: false,
      text_tracks: autoTextTracks,
    } as UploadConfig
  )

  // If user-provided config is disabled, begin the upload immediately with
  // the developer-specified values from the schema or config or defaults.
  // This can include auto-generated subtitles!
  const {disableTextTrackConfig, disableUploadConfig} = pluginConfig
  const skipConfig = disableTextTrackConfig && disableUploadConfig
  useEffect(() => {
    if (skipConfig) startUpload(formatUploadConfig(config))
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])
  if (skipConfig) return null

  const maxSupportedResolution = RESOLUTION_OPTIONS.findIndex(
    (rt) => rt.value === pluginConfig.max_resolution
  )
  return (
    <Dialog
      animate
      open
      id="upload-configuration"
      zOffset={1000}
      width={1}
      header="Configure ImageKit Upload"
      onClose={onClose}
    >
      <Stack padding={4} space={2}>
        <Label size={3}>FILE TO UPLOAD</Label>
        <Card
          tone="transparent"
          border
          padding={3}
          paddingY={4}
          style={{borderRadius: '0.1865rem'}}
        >
          <Flex gap={2}>
            <DocumentVideoIcon fontSize="2em" />
            <Stack space={2}>
              <Text textOverflow="ellipsis" as="h2" size={3}>
                {stagedUpload.type === 'file' ? stagedUpload.files[0].name : stagedUpload.url}
              </Text>
              <Text as="p" size={1} muted>
                {stagedUpload.type === 'file'
                  ? `Direct File Upload (${formatBytes(stagedUpload.files[0].size)})`
                  : 'File From URL (Unknown size)'}
              </Text>
            </Stack>
          </Flex>
        </Card>
        {!disableUploadConfig && (
          <Stack space={3} paddingBottom={2}>
            <FormField
              title="Video Transformation"
              description="How ImageKit should transform the video"
              inputId={`${id}-transformation`}
            >
              <Stack space={2}>
                {TRANSFORMATION_OPTIONS.map(({value, label}) => {
                  return (
                    <Flex align="center" gap={2} key={value}>
                      <Radio
                        id={`${id}-transformation-${value}`}
                        value={value}
                        checked={config.transformation === value}
                        style={{display: 'block'}}
                        onChange={(e) => {
                          dispatch({
                            action: 'transformation',
                            value: e.currentTarget.value as UploadConfig['transformation'],
                          })
                        }}
                      />
                      <Box flex={1}>
                        <Label as="label" htmlFor={`${id}-transformation-${value}`} muted={false}>
                          {label}
                        </Label>
                      </Box>
                    </Flex>
                  )
                })}
              </Stack>
            </FormField>

            {maxSupportedResolution > 0 && (
              <FormField
                title="Maximum Resolution"
                description="Maximum resolution for the video to be stored at. This does not affect adaptive streaming, the video will be available at all lower resolutions."
                inputId={`${id}-max_resolution`}
              >
                <Stack space={2}>
                  {RESOLUTION_OPTIONS.map(({value, label}, index) => {
                    const disabled = index > maxSupportedResolution
                    return (
                      <Flex align="center" gap={2} key={value}>
                        <Radio
                          id={`${id}-max_resolution-${value}`}
                          value={value}
                          disabled={disabled}
                          checked={config.max_resolution === value}
                          style={{display: 'block'}}
                          onChange={(e) => {
                            dispatch({
                              action: 'max_resolution',
                              value: e.currentTarget.value as UploadConfig['max_resolution'],
                            })
                          }}
                        />
                        <Box flex={1}>
                          <Label
                            as="label"
                            htmlFor={`${id}-max_resolution-${value}`}
                            muted={disabled}
                          >
                            {label}
                          </Label>
                        </Box>
                      </Flex>
                    )
                  })}
                </Stack>
              </FormField>
            )}

            <FormField
              title="Quality"
              description="Video quality (0-100). Higher values result in better quality but larger files."
              inputId={`${id}-quality`}
            >
              <input
                id={`${id}-quality`}
                type="range"
                min="0"
                max="100"
                value={config.quality}
                onChange={(e) => {
                  dispatch({
                    action: 'quality',
                    value: parseInt(e.currentTarget.value, 10),
                  })
                }}
                style={{width: '100%'}}
              />
              <Text align="center">{config.quality}</Text>
            </FormField>

            <FormField
              title="Privacy Settings"
              description="Whether the video should be private and require authentication to access."
              inputId={`${id}-private`}
            >
              <Flex align="center" gap={2}>
                <Checkbox
                  id={`${id}-private`}
                  checked={config.private}
                  style={{display: 'block'}}
                  onChange={(e) => {
                    dispatch({
                      action: 'private',
                      value: e.currentTarget.checked,
                    })
                  }}
                />
                <Box flex={1}>
                  <Label htmlFor={`${id}-private`}>Make video private</Label>
                </Box>
              </Flex>
            </FormField>

            {!disableTextTrackConfig && (
              <FormField
                title="Text Tracks"
                description="Add subtitles or captions to your video"
                inputId={`${id}-text-tracks`}
              >
                <TextTracksEditor
                  dispatch={dispatch}
                  tracks={config.text_tracks}
                  defaultLang={pluginConfig.defaultAutogeneratedSubtitleLang}
                />
              </FormField>
            )}
          </Stack>
        )}

        <Box marginTop={4}>
          <Button
            icon={UploadIcon}
            text="Upload"
            tone="positive"
            onClick={() => startUpload(formatUploadConfig(config))}
          />
        </Box>
      </Stack>
    </Dialog>
  )
}

function formatUploadConfig(config: UploadConfig): ImageKitNewAssetSettings {
  const generated_subtitles = config.text_tracks
    .filter<AutogeneratedTextTrack>(isAutogeneratedTrack)
    .map<{name: string; language_code: SupportedLanguage}>((track) => ({
      name: track.name,
      language_code: track.language_code,
    }))

  return {
    transformation: config.transformation,
    max_resolution: config.max_resolution,
    quality: config.quality,
    isPrivate: config.private,
    generated_subtitles: generated_subtitles.length > 0 ? generated_subtitles : undefined,
    // Add custom subtitles if needed
    customMetadata: {
      hasSubtitles: config.text_tracks.length > 0 ? 'true' : 'false',
    },
  }
}
