import type {ObjectInputProps, PreviewLayoutKey, PreviewProps, SchemaType} from 'sanity'
import type {PartialDeep} from 'type-fest'

export interface ImageKitInputConfig {
  /**
   * Determines video quality (0-100) with 80 being the default.
   * Higher values result in better quality but larger file sizes.
   * @defaultValue 80
   */
  quality: number

  /**
   * Transformation profile to use for the video.
   * Can be 'auto' or any custom transformation ID from ImageKit.
   * @defaultValue 'auto'
   */
  transformation: string

  /**
   * Maximum resolution of the video (height).
   * @defaultValue '1080p'
   */
  max_resolution: '2160p' | '1440p' | '1080p' | '720p' | '480p'

  /**
   * Enables private URLs by default, requiring authentication to access.
   * @defaultValue false
   */
  defaultPrivate?: boolean

  /**
   * Auto-generate captions for these languages by default.
   * @deprecated use `defaultAutogeneratedSubtitleLang` instead. Only a single autogenerated
   */
  defaultAutogeneratedSubtitleLangs?: SupportedLanguage[]

  /**
   * Auto-generate captions for this language by default.
   */
  defaultAutogeneratedSubtitleLang?: SupportedLanguage

  /**
   * Whether or not to allow content editors to override asset upload
   * configuration settings when uploading a video to ImageKit.
   *
   * @defaultValue false
   */
  disableUploadConfig?: boolean

  /**
   * Whether or not to allow content editors to add text tracks alongside their
   * asset when uploading a video to ImageKit.
   *
   * @defaultValue false
   */
  disableTextTrackConfig?: boolean
}

export interface PluginConfig extends ImageKitInputConfig {
  /**
   * How the videos browser should appear as a studio tool in Sanity's top navigation
   *
   * Pass `false` if you want to disable it.
   * @defaultValue {title: 'Videos', icon: VideoIcon}
   **/
  tool:
    | false
    | {
        title?: string
        icon?: React.ComponentType
      }
}

export const SUPPORTED_LANGUAGES = [
  {label: 'English', code: 'en', state: 'Stable'},
  {label: 'Spanish', code: 'es', state: 'Stable'},
  {label: 'Italian', code: 'it', state: 'Stable'},
  {label: 'Portuguese', code: 'pt', state: 'Stable'},
  {label: 'German', code: 'de', state: 'Stable'},
  {label: 'French', code: 'fr', state: 'Stable'},
  {label: 'Polish', code: 'pl', state: 'Beta'},
  {label: 'Russian', code: 'ru', state: 'Beta'},
  {label: 'Dutch', code: 'nl', state: 'Beta'},
  {label: 'Catalan', code: 'ca', state: 'Beta'},
  {label: 'Turkish', code: 'tr', state: 'Beta'},
  {label: 'Swedish', code: 'sv', state: 'Beta'},
  {label: 'Ukrainian', code: 'uk', state: 'Beta'},
  {label: 'Norwegian', code: 'no', state: 'Beta'},
  {label: 'Finnish', code: 'fi', state: 'Beta'},
  {label: 'Slovak', code: 'sk', state: 'Beta'},
  {label: 'Greek', code: 'el', state: 'Beta'},
  {label: 'Czech', code: 'cs', state: 'Beta'},
  {label: 'Croatian', code: 'hr', state: 'Beta'},
  {label: 'Danish', code: 'da', state: 'Beta'},
  {label: 'Romanian', code: 'ro', state: 'Beta'},
  {label: 'Bulgarian', code: 'bg', state: 'Beta'},
] as const

export const TRANSFORMATION_OPTIONS = [
  {label: 'Auto', value: 'auto'},
  {label: 'Custom', value: 'custom'},
] as const

export const SUPPORTED_LANGUAGES_VALUES = SUPPORTED_LANGUAGES.map((l) => l.code)

export type SupportedLanguage = (typeof SUPPORTED_LANGUAGES_VALUES)[number]

export interface TextTrack {
  _id: string
  name: string
}

export interface AutogeneratedTextTrack extends TextTrack {
  type: 'autogenerated'
  language_code: SupportedLanguage
}

export interface CustomTextTrack extends TextTrack {
  type: 'subtitles' | 'captions'
  language_code: string
  file: {
    contents: string
    type: string
    name: string
    size: number
  }
}

export function isCustomTextTrack(track: Partial<UploadTextTrack>): track is CustomTextTrack {
  return track.type !== 'autogenerated'
}

export function isAutogeneratedTrack(
  track: Partial<UploadTextTrack>
): track is AutogeneratedTextTrack {
  return track.type === 'autogenerated'
}

export type UploadTextTrack = AutogeneratedTextTrack | CustomTextTrack

export interface UploadConfig
  extends Pick<ImageKitInputConfig, 'transformation' | 'max_resolution' | 'quality'> {
  text_tracks: UploadTextTrack[]
  private: boolean
  is_protected: boolean
}

/**
 * Data sent to ImageKit to create a new asset.
 * @docs {@link https://docs.imagekit.io/api-reference/upload-file-api}
 */
export interface ImageKitNewAssetSettings
  extends Pick<ImageKitInputConfig, 'transformation' | 'max_resolution' | 'quality'> {
  /** The file to upload */
  file?: File | string

  /** Name of the file if uploading a file object directly */
  fileName?: string

  /** Whether the file should be private (requires authentication) */
  isPrivate?: boolean

  /** Folder path where the file has to be uploaded */
  folder?: string

  /** Set the file as moderation pending */
  useUniqueFileName?: boolean

  /** Array of tags associated with the video */
  tags?: string[]

  /** Generate subtitle tracks using automatic speech recognition with this configuration */
  generated_subtitles?: {
    /** A name for this subtitle track. */
    name: string
    /** Arbitrary metadata set for the subtitle track. Max 255 characters. */
    passthrough?: string
    /** The language to generate subtitles in. */
    language_code: SupportedLanguage
  }[]

  /** Custom metadata fields as key-value pairs */
  customMetadata?: Record<string, string>

  /** Extensions to apply to the upload */
  extensions?: {
    name: string
    options: Record<string, unknown>
  }[]
}

export interface Secrets {
  publicKey: string | null
  privateKey: string | null
  urlEndpoint: string | null
  enablePrivateImages: boolean
}

// This narrowed type indicates that credentials are properly configured
export interface ConfiguredSecrets extends Secrets {
  publicKey: string
  privateKey: string
  urlEndpoint: string
}

export type ImageKitOrigin = `https://${string}.imagekit.io`
export type ImageKitThumbnailUrl = `${ImageKitOrigin}/${string}/thumbnail.jpg?${string}`
export type ImageKitAnimatedThumbnailUrl = `${ImageKitOrigin}/${string}/animated.gif?${string}`
export type ImageKitVideoUrl = `${ImageKitOrigin}/${string}/video?${string}`
export type ImageKitApiUrl = ImageKitThumbnailUrl | ImageKitAnimatedThumbnailUrl | ImageKitVideoUrl

// 'preserve' by default
export type FitMode = 'cover' | 'contain' | 'fill' | 'pad'

export interface ThumbnailOptions {
  fit?: FitMode
  height?: number
  time?: number
  width?: number
}

export interface AnimatedThumbnailOptions {
  // Starting time code for the animation
  start?: number
  // End code
  end?: number
  // Width of the animated thumbnail
  width?: number
  // Height of the animated thumbnail
  height?: number
  // The fps
  fps?: number
}

export interface AssetThumbnailOptions {
  asset: {
    url?: string
    data?: Record<string, unknown>
    thumbTime?: number
    filename?: string
    fileId?: string
  }
}

export type PrivacyPolicy = 'private' | 'public'

export interface ImageKitErrors {
  type: string
  messages: string[]
}

export interface ImageKitTransformation {
  name: string
  params: string
}

export interface ImageKitVideoMetadata {
  id: string
  type: string
  width: number
  height: number
  duration: number
  size: number
}

export interface ImageKitAudioMetadata {
  id: string
  type: string
  duration: number
  channels: number
  bitrate: number
}

export interface ImageKitTextTrack {
  type: 'text'
  id: string
  text_type?: 'subtitles'
  language?: string
  source?: 'uploaded' | 'embedded' | 'generated'
  // BCP 47 language code
  language_code?: 'en' | 'en-US' | string
  // The name of the track
  name?: 'English' | string
  closed_captions?: boolean
  //  Max 255 characters
  passthrough?: string
  status: 'preparing' | 'ready' | 'errored'
}

export type ImageKitMetadata = ImageKitVideoMetadata | ImageKitAudioMetadata

// Types based on ImageKit API
export interface ImageKitAsset {
  fileId: string
  name: string
  /** Created date */
  created: string
  status: 'processing' | 'ready' | 'errored'
  type: 'file' | 'image' | 'video' | 'audio'
  filePath: string
  tags: string[]
  isPrivateFile: boolean
  customCoordinates: string | null
  url: string
  thumbnail: string
  fileType: string
  mime: string
  height: number
  width: number
  size: number
  hasAlpha: boolean
  customMetadata: Record<string, unknown>
  embeddedMetadata: Record<string, unknown>
  metadata: ImageKitMetadata[]
  AITags: string[]

  // Video-specific properties
  duration?: number
  thumbnailUrl?: string
  videoUrl?: string
  // Video processing options
  quality?: number
  // Video formats and transformations
  transformations?: ImageKitTransformation[]
  // Video formats information
  formats?: {
    status: 'ready' | 'processing' | 'failed'
    formats: {
      format: string
      url: string
      height: number
      width: number
      bitrate: number
      filesize: number
    }[]
  }
  // Video content information
  content_info?: {
    duration: number
    framerate: number
    width: number
    height: number
    bitrate: number
    codec: string
    aspect_ratio: string
  }
}

export interface VideoAssetDocument {
  _id: string
  _type: 'imagekit.videoAsset'
  _createdAt: string
  _updatedAt?: string
  status?: string
  fileId?: string
  url?: string
  filename?: string
  thumbTime?: number
  // Data from ImageKit API
  data?: PartialDeep<ImageKitAsset>
}

export type Reference = {_type: 'reference'; _ref: string}

export type ImageKitInputProps = ObjectInputProps<{
  asset?: Reference
}>

export interface ImageKitInputPreviewProps extends Omit<PreviewProps<PreviewLayoutKey>, 'value'> {
  schemaType: SchemaType
  value?: {
    asset?: Reference
  } | null
}

/** Whether the VideosBrowser was opened from a field in a document, or from the standalone studio tool */
export type PluginPlacement = 'input' | 'tool'

/** Upload event types for file/URL upload observables */
export type UploadEvent =
  | {type: 'file'; file: File; uuid: string}
  | {type: 'url'; url: string}
  | {type: 'progress'; percent: number}
  | {type: 'success'; id: string; asset: VideoAssetDocument}
  | {type: 'error'; error: Error}
  | {type: 'uuid'; uuid: string}
  | {type: 'pause'}
  | {type: 'resume'}
